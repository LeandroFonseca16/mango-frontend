#!/usr/bin/env python3
"""Generate synthetic trend events and tiny audio loops for local testing.

The script creates:
  * WAV files with simple sine-based loops
  * JSON payload describing trend events and derived features
  * Optional SQL file with INSERT statements for PostgreSQL
"""

from __future__ import annotations

import argparse
import json
import math
import os
import random
import sys
import uuid
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import List
import wave
import struct

SAMPLE_RATE_DEFAULT = 22050
DURATION_DEFAULT = 12.0  # seconds

PLATFORMS = ["TIKTOK", "YOUTUBE_SHORTS", "INSTAGRAM_REELS"]
INSTRUMENT_TAGS = [
    "synth",
    "bass",
    "drums",
    "guitar",
    "pads",
    "vocals",
    "fx",
    "piano",
]
SECTIONS = ["intro", "build", "drop", "break", "outro"]
MUSICAL_KEYS = [
    "C major",
    "D major",
    "E major",
    "F major",
    "G major",
    "A major",
    "B major",
    "A minor",
    "C minor",
    "D minor",
    "E minor",
    "G minor",
]


@dataclass
class TrendFeatures:
    bpm: int
    key: str
    energy: float
    loudness: float
    spectral_flux: float
    instrument_tags: List[str]
    sections: List[dict]


@dataclass
class TrendEvent:
    id: str
    platform: str
    sourceUrl: str
    title: str
    caption: str
    hashtags: List[str]
    views: int
    likes: int
    comments: int
    shares: int
    durationSec: int
    collectedAt: str
    isInstrumentalCandidate: bool
    viralScore: float
    metadata: dict
    features: TrendFeatures


def generate_wave_file(path: Path, frequency: float, duration: float, sample_rate: int) -> None:
    """Create a simple sine wave loop."""
    total_samples = int(duration * sample_rate)
    amplitude = 0.35
    with wave.open(str(path), "w") as wav_file:
        wav_file.setnchannels(1)
        wav_file.setsampwidth(2)  # 16-bit PCM
        wav_file.setframerate(sample_rate)
        for index in range(total_samples):
            sample = amplitude * math.sin(2.0 * math.pi * frequency * index / sample_rate)
            wav_file.writeframes(struct.pack("<h", int(sample * 32767)))


def random_sections(duration: float) -> List[dict]:
    """Return simple structural markers across the loop."""
    checkpoints = [0.0]
    remaining_labels = SECTIONS[1:-1]
    random.shuffle(remaining_labels)
    for _ in range(3):
        checkpoints.append(random.uniform(0.5, duration - 0.5))
    checkpoints.append(duration)
    checkpoints = sorted(set(checkpoints))
    labels = [SECTIONS[0]] + remaining_labels[: len(checkpoints) - 2] + [SECTIONS[-1]]
    sections = []
    for idx in range(len(checkpoints) - 1):
        sections.append(
            {
                "label": labels[idx],
                "start": round(checkpoints[idx], 3),
                "duration": round(checkpoints[idx + 1] - checkpoints[idx], 3),
            }
        )
    return sections


def calculate_viral_score(views: int, likes: int, comments: int, shares: int, energy: float) -> float:
    engagement = likes * 0.25 + comments * 0.5 + shares * 0.75
    base = views * 0.0001
    return round((base + engagement) * (1 + energy * 0.4), 2)


def to_pg_array(values: List[str]) -> str:
    escaped = [value.replace('"', '\"') for value in values]
    inner = ",".join(f'"{value}"' for value in escaped)
    return f'{{{inner}}}'


def build_trend(index: int, output_dir: Path, duration: float, sample_rate: int) -> TrendEvent:
    trend_id = uuid.uuid4().hex
    platform = random.choice(PLATFORMS)
    frequency = random.uniform(110.0, 880.0)
    title = f"Synthetic Loop #{index:03d}"
    caption = random.choice([
        "Fresh loop generated by MangoBeat AI",
        "Trending vibe ready for TikTok edits",
        "Auto-generated groove for rapid prototyping",
    ])
    hashtags = ["synthetic", "autogen", platform.lower()]
    audio_dir = output_dir / "audio"
    audio_dir.mkdir(parents=True, exist_ok=True)
    file_name = f"trend_{index:03d}.wav"
    audio_path = audio_dir / file_name
    generate_wave_file(audio_path, frequency, duration, sample_rate)

    bpm = random.randint(70, 160)
    energy = round(random.uniform(0.3, 0.95), 2)
    features = TrendFeatures(
        bpm=bpm,
        key=random.choice(MUSICAL_KEYS),
        energy=energy,
        loudness=round(random.uniform(-18.0, -6.0), 2),
        spectral_flux=round(random.uniform(0.1, 0.8), 3),
        instrument_tags=random.sample(INSTRUMENT_TAGS, k=random.randint(2, 4)),
        sections=random_sections(duration),
    )

    views = random.randint(50_000, 2_000_000)
    likes = random.randint(1_000, 150_000)
    comments = random.randint(120, 8_500)
    shares = random.randint(200, 12_000)
    viral_score = calculate_viral_score(views, likes, comments, shares, energy)

    metadata = {
        "synthetic": True,
        "audioPath": str(audio_path.relative_to(output_dir.parent).as_posix()),
        "frequency": round(frequency, 2),
        "sampleRate": sample_rate,
    }

    collected_at = datetime.now(timezone.utc).isoformat()
    source_url = f"https://example.com/trends/{trend_id}"

    return TrendEvent(
        id=trend_id,
        platform=platform,
        sourceUrl=source_url,
        title=title,
        caption=caption,
        hashtags=hashtags,
        views=views,
        likes=likes,
        comments=comments,
        shares=shares,
        durationSec=int(duration),
        collectedAt=collected_at,
        isInstrumentalCandidate=True,
        viralScore=viral_score,
        metadata=metadata,
        features=features,
    )


def write_json(events: List[TrendEvent], output_dir: Path) -> Path:
    payload = {
        "generatedAt": datetime.now(timezone.utc).isoformat(),
        "count": len(events),
        "events": [
            {
                **asdict(event),
                "features": asdict(event.features),
            }
            for event in events
        ],
    }
    json_path = output_dir / "synthetic_trend_events.json"
    json_path.write_text(json.dumps(payload, indent=2))
    return json_path


def write_sql(events: List[TrendEvent], output_dir: Path) -> Path:
    lines = ["-- Synthetic trend_events generated for local testing"]
    for event in events:
        metadata_json = json.dumps(event.metadata).replace("'", "''")
        hashtags_literal = to_pg_array(event.hashtags)
        statement = (
            "INSERT INTO trend_events (id, platform, source_url, title, caption, hashtags, views, likes, comments, shares, duration_sec, collected_at, is_instrumental_candidate, viral_score, metadata) "
            f"VALUES ('{event.id}', '{event.platform}', '{event.sourceUrl}', '{event.title.replace("'", "''")}', "
            f"'{event.caption.replace("'", "''")}', '{hashtags_literal}'::text[], {event.views}, {event.likes}, {event.comments}, {event.shares}, {event.durationSec}, "
            f"'{event.collectedAt}', {str(event.isInstrumentalCandidate).lower()}, {event.viralScore}, '{metadata_json}'::jsonb) ON CONFLICT (source_url) DO NOTHING;"
        )
        lines.append(statement)
    sql_path = output_dir / "synthetic_trend_events.sql"
    sql_path.write_text("\n".join(lines) + "\n")
    return sql_path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate synthetic trend data and audio loops.")
    parser.add_argument("--count", type=int, default=100, help="Number of synthetic trend events to generate (default: 100)")
    parser.add_argument("--duration", type=float, default=DURATION_DEFAULT, help="Audio loop duration in seconds (default: 12.0)")
    parser.add_argument("--sample-rate", type=int, default=SAMPLE_RATE_DEFAULT, help="Sample rate for generated audio (default: 22050)")
    parser.add_argument("--output-dir", type=Path, default=Path("data/synthetic"), help="Directory where assets will be written")
    parser.add_argument("--seed", type=int, help="Optional random seed for reproducible data")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    if args.seed is not None:
        random.seed(args.seed)

    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)

    events: List[TrendEvent] = []
    for index in range(1, args.count + 1):
        events.append(build_trend(index, output_dir, args.duration, args.sample_rate))

    json_path = write_json(events, output_dir)
    sql_path = write_sql(events, output_dir)

    print(f"Generated {len(events)} synthetic trends")
    print(f"JSON payload: {json_path.relative_to(Path.cwd()) if json_path.is_absolute() else json_path}")
    print(f"SQL script : {sql_path.relative_to(Path.cwd()) if sql_path.is_absolute() else sql_path}")
    print(f"Audio files: {(output_dir / 'audio').relative_to(Path.cwd()) if output_dir.is_absolute() else output_dir / 'audio'}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(130)
```